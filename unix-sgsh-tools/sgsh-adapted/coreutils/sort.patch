--- ../coreutils/src/coreutils-sort.c	2016-05-21 17:09:49.487237740 +0300
+++ ../sgsh-adapted/coreutils/sort.c	2016-06-13 20:09:53.268929454 +0300
@@ -53,6 +53,10 @@
 #include "xnanosleep.h"
 #include "xstrtol.h"
 
+/*  sgsh negotiate API (fix -I) */
+#include <assert.h>
+#include "sgsh-negotiate.h"
+
 #ifndef RLIMIT_DATA
 struct rlimit { size_t rlim_cur; };
 # define getrlimit(Resource, Rlp) (-1)
@@ -1551,7 +1555,6 @@
         return size_bound;
       size += worst_case;
     }
-
   return size;
 }
 
@@ -3876,8 +3879,9 @@
 
 /* Sort NFILES FILES onto OUTPUT_FILE.  Use at most NTHREADS threads.  */
 
+/* sgsh: char ***files to be able to adapt file names */
 static void
-sort (char *const *files, size_t nfiles, char const *output_file,
+sort (char ***files, size_t nfiles, char const *output_file,
       size_t nthreads)
 {
   struct buffer buf;
@@ -3885,13 +3889,68 @@
   size_t ntemps = 0;
   bool output_file_created = false;
 
+  /* sgsh */
+  int j = 0;
+  int ninputfds = -1;
+  int noutputfds = -1;
+  int *inputfds;
+  int *outputfds;
+  char sgshin[10];
+  char sgshout[11];
+  int status = -1;
+  int count_stdin_files = 0;
+
   buf.alloc = 0;
 
-  while (nfiles)
+  /* sgsh */
+  if (!isatty(fileno(stdin))) strcpy(sgshin, "SGSH_IN=1");
+  else strcpy(sgshin, "SGSH_IN=0");
+  putenv(sgshin);
+  if (!isatty(fileno(stdout))) strcpy(sgshout, "SGSH_OUT=1");
+  else strcpy(sgshout, "SGSH_OUT=0");
+  putenv(sgshout);
+  if ((status = sgsh_negotiate("sort", -1, 1, &inputfds, &ninputfds, &outputfds,
+                                                          &noutputfds))) {
+    printf("sgsh negotiation failed with status code %d.\n", status);
+    exit(1);
+  }
+
+  /* Count stdin input file directives */
+  for (j = 0; j < nfiles; j++)
     {
+    const char *file = (*files)[j];
+    //printf("sort: input file: %s\n", file);
+    if (STREQ(file, "-")) count_stdin_files++;
+    }
+  
+  /**
+   * Realloc space in file name array to accommodate the implicit
+   * input streams coming from sgsh.
+   */
+  if (ninputfds > count_stdin_files)
+    {
+    nfiles += ninputfds - 1;
+    *files = xnrealloc (*files, nfiles, sizeof **files);
+    for (j = nfiles - ninputfds +1; j < nfiles; j++)
+      (*files)[j] = (*files)[0];
+    }
+    j = 0;
+
+  while (nfiles)
+    { 
       char const *temp_output;
-      char const *file = *files;
-      FILE *fp = xfopen (file, "r");
+      /* sgsh */
+      int m = 0;
+      char const *file = (*files)[m];
+      FILE *fp;
+      /* sgsh */
+      if (STREQ(file, "-"))
+        {
+        fp = fdopen(inputfds[j++], "r");
+        have_read_stdin = true;
+        }
+      else
+        fp = xfopen (file, "r");
       FILE *tfp;
 
       size_t bytes_per_line;
@@ -3912,9 +3971,9 @@
 
       if (! buf.alloc)
         initbuf (&buf, bytes_per_line,
-                 sort_buffer_size (&fp, 1, files, nfiles, bytes_per_line));
+                 sort_buffer_size (&fp, 1, *files, nfiles, bytes_per_line));
       buf.eof = false;
-      files++;
+      m++;
       nfiles--;
 
       while (fillbuf (&buf, fp, file))
@@ -3937,7 +3996,9 @@
           if (buf.eof && !nfiles && !ntemps && !buf.left)
             {
               xfclose (fp, file);
-              tfp = xfopen (output_file, "w");
+              /* sgsh */
+              if (noutputfds > 0) tfp = fdopen(outputfds[0], "w");
+              else tfp = xfopen (output_file, "w");
               temp_output = output_file;
               output_file_created = true;
             }
@@ -4563,6 +4624,7 @@
         }
     }
 
+  /* sgsh here too? */
   if (files_from)
     {
       FILE *stream;
@@ -4749,7 +4811,7 @@
       size_t nthreads_max = SIZE_MAX / (2 * sizeof (struct merge_node));
       nthreads = MIN (nthreads, nthreads_max);
 
-      sort (files, nfiles, outfile, nthreads);
+      sort (&files, nfiles, outfile, nthreads);
     }
 
 #ifdef lint
